# ACTIVITY2 Packet - ID 26 #

## Description ##
One second of raw activity samples as little-endian signed-shorts in XYZ order.

## Format of Data ##

## Scaling Activity Values ##
Once a sample has been parsed we must:

1. Scale the resultant by the scale factor (this gives us an acceleration value in g's). Device serial numbers starting with NEO and CLE use a scale factor of 341 LSB/g (±6g). MOS devices use a 256 LSB/g scale factor (±8g). If a LOG_PARAMETER record is preset, then the ACCEL_SCALE value should be used.
2. Round the value from #2 to three decimal places.

## Activity Log Record Type with 1-Byte Payload ##
An 'Activity2' (id: 0x1A) log record type with a 1-byte payload is captured on a USB connection event (and does not represent a reading from the activity monitor's accelerometer). This event is captured upon docking the activity monitor (via USB) to a PC or CentrePoint Data Hub (CDH) device. Therefore such records cannot be parsed as the traditional activity log record which consists of YXZ samples. 


## Example ##
```
0x00 0x00 0x00 0x00 0x00 0x00 0x30 0x00 0xcc 0xff 0x42 0x01 0x03 0x00 0xfa 0xff
0x01 0x01 0x02 0x00 0xfc 0xff 0x02 0x01 0x01 0x00 0xfd 0xff 0x01 0x01 0x02 0x00
0xfe 0xff 0x00 0x01 0x02 0x00 0xfd 0xff 0x01 0x01 0x02 0x00 0xfc 0xff 0x02 0x01
0x02 0x00 0xfd 0xff 0x02 0x01 0x02 0x00 0xfc 0xff 0x00 0x01 0x02 0x00 0xfd 0xff
0x01 0x01 0x01 0x00 0xfd 0xff 0x00 0x01 0x02 0x00 0xfd 0xff 0xff 0x00 0x01 0x00
0xfd 0xff 0x01 0x01 0x02 0x00 0xfd 0xff 0x00 0x01 0x02 0x00 0xfd 0xff 0x02 0x01
0x01 0x00 0xfe 0xff 0x00 0x01 0x02 0x00 0xfb 0xff 0x00 0x01 0x02 0x00 0xfd 0xff
0x00 0x01 0x01 0x00 0xfd 0xff 0x02 0x01 0x01 0x00 0xfd 0xff 0x01 0x01 0x01 0x00
0xfc 0xff 0x00 0x01 0x02 0x00 0xfd 0xff 0x00 0x01 0x01 0x00 0xfc 0xff 0x02 0x01
0x02 0x00 0xfc 0xff 0xff 0x00 0x02 0x00 0xfd 0xff 0x02 0x01 0x02 0x00 0xfc 0xff
0x00 0x01 0x02 0x00 0xfd 0xff 0x01 0x01 0x00 0x00 0xfc 0xff 0x01 0x01 0x02 0x00
0xfd 0xff 0x01 0x01 
```

<table>
    <tr>
        <th>Offset (bytes)</th>
        <th>Axis</th>
        <th>Hex value</th>
        <th>Int16 value</th>
		<th>After scale factor</th>
    </tr>
    <tr>
        <td>0</td>
        <td>X</td>
        <td>0x00 0x00</td>
        <td>0</td>
		<td>0</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Y</td>
        <td>0x00 0x00</td>
        <td>0</td>
		<td>0</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Z</td>
        <td>0x00 0x00</td>
        <td>0</td>
		<td>0</td>
    </tr>
    <tr>
        <td>6</td>
        <td>X</td>
        <td>0x30 0x00</td>
        <td>48</td>
		<td>0.188</td>
    </tr>
    <tr>
        <td>8</td>
        <td>Y</td>
        <td>0xCC 0xFF</td>
        <td>-52</td>
		<td>-0.203</td>
    </tr>
    <tr>
        <td>10</td>
        <td>Z</td>
        <td>0x42 0x01</td>
        <td>332</td>
		<td>1.258</td>
    </tr>
	<tr>
		<td colspan="5">and so on...</td>
	</tr>
</table>


## Sample C# Parsing Code ##
```c#
int offset = 0;

for (int i = 0; i < SampleRateInHz; ++i)
{
	var xAxis = BitConverter.ToInt16(Payload, offset);
	offset += 2;
	var yAxis = BitConverter.ToInt16(Payload, offset);
	offset += 2;
	var zAxis = BitConverter.ToInt16(Payload, offset);
	offset += 2;

	xAxis /= _accelerationScaleFactor;
	yAxis /= _accelerationScaleFactor;	
	zAxis /= _accelerationScaleFactor;
}
```
